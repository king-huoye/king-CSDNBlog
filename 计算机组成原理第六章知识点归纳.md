# 计算机的运算方法

## 无符号数和有符号数

### 无符号数

即没有符号的数，在寄存器中的每一位均可用来存放数值。

### 有符号数

在有效数字前面用“0”表示“正”，用“1”表示“负”，即组成了有符号数。 原码、反码、补码三种机器数的特点可归纳如下 三种机器数的最高位均为符号位。符号位和数值部分之间可用“.”（对于小数）或“,”(对于整数)隔开 当真值为正时，原码、补码和反码的表示形式均相同，即符号位用“0”表示，数值部分与真值相同 当真值为负时，原码、补码和反码的表示形式不同，但其符号位都用“1”表示，而数值部分有这样的关系，即补码是原码的“求反加一”，反码是原码的“每位求反”

- 机器数和真值

    把符号“数字化”的数称为机器数，而把带“+”或“-”符号的数称为真值。

- 原码表示法

    原码是机器数中最简单的一种表示形式，符号位为0表示正数，符号位为1表示负数，数值位即真值的绝对值，故原码表示又称为带符号的绝对值表示。

    - 整数原码
    $\left [ x \right ]_{原}=\left\{\begin{matrix}
    0,x & 2^{n}> x\geq 0\\ 
    2^{n}-x & 0\geq x> -2^{n}
    \end{matrix}\right.$

        用逗号将符号位和数值部分隔开

    - 小数原码
    $\left [ x \right ]_{原}=\left\{\begin{matrix}
    x & 1> x\geq 0\\ 
    1-x & 0\geq x> -1
    \end{matrix}\right.$
    - 当x=0时
        - [+0.0000]原=0.0000
        - [-0.0000]原=1-(0.0000)=1.0000
- 补码表示法

    一个负数可用它的正补数来代替，而这个正补数可以用模加上负数本身求得 一个正数和一个负数互为补数时，它们绝对值之和即为模数 正数的补数即该正数本身 当x为负数时，x的补码为x的原码除符号位外，每位求反加1

    - 整数补码
    $\left [ x \right ]_{补}=\left\{\begin{matrix}0,x & 2^{n}> x\geq 0\\ 2^{n+1}+x & 0>  x\geq -2^{n} (mod 
    2^{n+1})\end{matrix}\right.$
    - 小数补码
    $\left [ x \right ]_{补}=\left\{\begin{matrix}0,x & 1> x\geq 0\\ 2+x & 0>  x\geq -1 (mod 
    2^{n})\end{matrix}\right.$
    - 当x=0时
        - $[+0.0000]_补$=0.0000
        - $[-0.0000]_补$=2+(-0.0000)=0.0000
    - 当x=-1时
        - $[-1]_补$=2+x=10.0000-1.0000=1.0000
- 反码表示法
    - 整数反码
    $\left [ x \right ]_{反}=\left\{\begin{matrix}0,x & 2^{n}> x\geq 0\\ \left (2^{n+1}-1  \right )+x & 0\geq   x>  -2^{n} (mod \left (
    2^{n+1}-1  \right ))\end{matrix}\right.$
    - 小数反码
    $\left [ x \right ]_{反}=\left\{\begin{matrix}
     x& 1> x\geq 0\\ 
     (2-2^{-n})+x& 0\geq x> -1    (mod(2-2^{-n}))
    \end{matrix}\right.$
    - 当x=0时
        - $[+0.0000]_反$=0.0000
        - $[-0.0000]_反$=(10.0000-0.0001)-0.0000=1.1111
- 移码表示法

    对每个真值加上一个2^n（n为整数的位数）

    $[x]_移=2^n +x$    $(2^n>x>=-2^n)$

    - 同一个真值的移码和补码仅差一个符号位

## 数的定点表示和浮点表示

定点表示的数称为定点数，浮点表示的数称为浮点数。

### 定点表示

小数点固定在某一位置的数为定点数。 小数点位于数符和第一数值位之间时，机器内的数为纯小数；当小数点位于数值位之后时，机器内的数为纯整数。 采用定点数的机器称为定点机。

- 小数定点机

    表示范围是：-(1 - 2^(-n))~(1 - 2^(-n))

- 整数定点机

    表示范围是：-(2^n - 1)~(2^n - 1)

### 浮点表示

通常，浮点数被表示成：N=S x r^j S为尾数（可正可负），j为阶码（可正可负），r是基数（或基值）。 将尾数最高位为1的浮点数称为规格化数。

- 浮点数的表示形式

    阶符|阶码的数值部分|数符|尾数的数值部分

- 浮点数的表示范围

    当浮点数阶码大于最大阶码时，称为上溢，此时机器停止运算，进行中断溢出处理；当浮点数阶码小于最小阶码时，称为下溢，此时溢出的数绝对值很小，通常将尾数各位强置为零，按机器零处理，此时机器可以继续运行。

- 浮点数的规格化

    当基数为2时，尾数最高位为1的数为规格化数； 当基数为4时，尾数的最高两位不全为零的数为规格化数； 当基数为8时，尾数的最高三位不全为零的数为规格化数。 基数r越大，可表示的浮点数范围越大，而且所表示的数的个数越多。但r越大，浮点数的精度反而下降。

### 定点数和浮点数的比较

- 当浮点机和定点机中数的位数相同时，浮点数的表示范围比定点数的大得多。
- 当浮点数为规格化数时，其相对精度远比定点数高。
- 浮点数运算要分阶码部分和尾数部分，而且运算结果都要求规格化，故浮点运算步骤比定点运算步骤多，运算速度比定点运算的低，运算线路比定点运算的复杂。
- 在溢出的判断方法上，浮点数是对规格化数的阶码进行判断，而定点数是对数值本身进行判断。

### 举例

- 当一个浮点数尾数为0时，不论其阶码为何值；或阶码等于或小于它所能表示的最小数时，不管其尾数为何值，机器都把该浮点数作为零看待，并称之为“机器零”。

### IEEE 754标准

尾数部分通常都是规格化表示，即非“0”的有效位最高位总是“1”，但在IEEE标准中，有效位呈如下形式。 1▲ffff……fff 其中▲表示假想的二进制小数点。在实际表示中，对短实数和长实数，这个整数位的1省略，称为隐藏位；对于临时实数不采用隐藏位方案。

- 短实数

    符号位S 阶码 尾数 总位数 1 8 23 32

- 长实数

    符号位S 阶码 尾数 总位数 1 11 52 64

- 临时实数

    符号位S 阶码 尾数 总位数 1 15 64 80

## 定点运算

定点运算包括移位、加、减、乘、除几种

### 移位运算

- 移位的意义

    移位运算称为移位操作，对计算机来说，有很大的实用价值。例如，当某计算机没有乘（除）法运算线路时，可以采用移位和加法相结合，实现乘（除）运算。 对有符号数的移位称为算术移位。

- 算术移位规则

    （6.4表格）

    - 机器数为正时，不论是左移还是右移，添补代码均为0。
    - 由于负数的原码数值部分与真值相同，故在移位时只要使符号位不变，其空位均添0即可。
    - 由于负数的反码各位除符号位外与负数的原码正好相反，故移位后所添的代码应与原码相反，即全部添1。
    - 分析任意负数的补码可发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位(包括此“1”在内)均与对应的原码相同。故负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0;右移时因空位出现在高位，则添补的代码应与反码相同，即添1。
- 算术移位和逻辑移位的区别
    - 有符号数的移位称为算术移位，无符号数的移位称为逻辑移位。
    - 逻辑移位的规则是：逻辑左移时，高位移丢，低位添0；逻辑右移时，低位移丢，高位添0。

### 加法与减法运算

- 补码加减运算的基本公式
    - 加法
        - 整数

            [A]补 + [B]补 = [A+B]补（mod 2^n+1）

        - 小数

            [A]补 + [B]补 = [A+B]补 mod 2）

    - 减法

        A - B = A + （-B） 则[A - B]补 = [A + (-B)]补

        - 整数

            [A-B]补 = [A]补 + [-B]补 (mod 2^n+1)

        - 小数

            [A-B]补 = [A]补 + [B]补 (mod 2)

- 溢出判断
    - 用一位符号位判断溢出

        不论是作加法还是减法，只要实际参加操作的两个数（减法时即为被减数和“求补”以后的减数）符号相同，结果又与原操作数的符号不同，即为溢出。

    - 用两位符号位判断溢出

        当2位符号位不同时，表示溢出，否则，无溢出。不论是否发生溢出，高位（第1位）符号位永远代表真正的符号。

- 补码定点加减法所需的硬件配置

    图6.5

- 补码加减运算控制流程

    图6.6

### 乘法运算

- 分析笔算乘法
- 笔算乘法的改进

    两数相乘的过程，可视为加法和移位（乘2^-1相当于做一位右移）两种运算

    - 乘法运算可用移位和加法来实现，两个4位数相乘，总共需要进行4次加法运算和4次移位。
    - 由乘数的末位值确定被乘数是否与原部分积相加，然后右移一位，形成新的部分积；同时，乘数也右移一位，由次低位作新的末位，空出最高位放部分积的最低位。
    - 每次做加法时，被乘数仅仅与原部分积的高位相加，其低位被移至乘数所空出的高位位置。
- 原码乘法
    - 原码一位乘运算规则

        乘积的符号位由两原码符号位异或运算结果决定 乘积的数值部分由两数绝对值相乘

    - 原码一位乘所需的硬件配置
    - 原码一位乘控制流程
    - 原码两位乘
- 补码乘法

### 除法运算

- 分析笔算除法
- 原码除法
- 补码除法

## 浮点四则运算

### 浮点加减运算

对阶，使两数的小数点位置对齐。 尾数求和，将对阶后的两尾数按定点加减运算规则求和(差)。 规格化，为增加有效数字的位数,提高运算精度，必须将求和(差)后的尾数规格化。舍入，为提高精度，要考虑尾数右移时丢失的数值位。 溢出判断，即判断结果是否溢出。

- 对阶

    对阶的目的是使两操作数的小数点位置对齐，即使两数的阶码相等。 为此，首先要求出阶差，再按小阶向大阶看齐的原则，使阶小的尾数向右移位，每右移一位，阶码加1，直到两数的阶码相等为止。 右移的次数正好等于阶差。 尾数右移时可能会发生数码丢失，影响精度。

- 尾数求和

    将对阶后的两个尾数按定点加（减）运算规则进行运算。

- 规格化

    当基值r=2时，尾数S的规格化形式为 1/2 <= |S| <1

    如果采用双符号位的补码 当S>0时，其补码规格化形式为 [S]补 = 00.1xx…x 当S<0时，其补码规格化形式为 [S]补 = 11.0xx…x

    可见，当尾数的最高数值位与符号位不同时，即为规格化形式，但对S<0时，有两种情况需特殊处理。 S=-1/2时，[S]补 = 11.100…0。特规定-1/2不是规格化的数（对补码而言） S=-1，[S]补 = 11.00…0。因小数补码允许表示-1，故-1视为规格化的数。

    - 左规

        当尾数出现00.0xx…x或11.1xx…x时，需左规。 左规时尾数左移一位，阶码减1，直到符合规格化形式为止。

    - 右规

        当尾数出现01.xxx…x或10.xxx…x时，表示尾数溢出，这在定点加减运算中是不允许的，但在浮点运算中这不算溢出，可通过右规处理。 右规时尾数右移一位，阶码加1。

- 舍入
    - “0舍1入”法

        尾数右移时，被移去的最高数值位为0，则舍去；被移去的最高数值位为1，则在尾数的末位加1。这样做可能使尾数又溢出，此时需再做一次右规。

    - “恒置1”法

        尾数右移时，不论丢掉的最高数值位是“1”或“0”，都使右移后的尾数末位恒置“1”。这种方法同样有使尾数变大和变小的两种可能。

- 溢出判断

### 浮点乘除法运算

- 阶码运算
- 尾数运算

### 浮点运算所需的硬件配置

## 算术逻辑单元

### ALU电路

### 快速进位链

- 并行加法器
- 串行进位链
- 并行进位链


